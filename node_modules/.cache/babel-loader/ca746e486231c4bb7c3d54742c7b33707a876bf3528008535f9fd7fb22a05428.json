{"ast":null,"code":"// Global error handler for browser extension conflicts and other errors\n\nexport class GlobalErrorHandler {\n  static init() {\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', event => {\n      console.warn('Unhandled promise rejection:', event.reason);\n\n      // Prevent browser extension errors from crashing the app\n      if (this.isBrowserExtensionError(event.reason)) {\n        console.info('Browser extension error detected and ignored:', event.reason);\n        event.preventDefault();\n        return;\n      }\n\n      // Log other errors for debugging\n      this.logError('Unhandled Promise Rejection', event.reason);\n    });\n\n    // Handle uncaught JavaScript errors\n    window.addEventListener('error', event => {\n      // Ignore browser extension errors\n      if (this.isBrowserExtensionError(event.error) || this.isBrowserExtensionError(event.filename)) {\n        console.info('Browser extension error detected and ignored:', event.error);\n        event.preventDefault();\n        return;\n      }\n      this.logError('Uncaught Error', event.error);\n    });\n\n    // Override console.error to filter out extension errors\n    const originalConsoleError = console.error;\n    console.error = (...args) => {\n      const errorString = args.join(' ');\n\n      // Don't log browser extension errors\n      if (this.isBrowserExtensionError(errorString)) {\n        return;\n      }\n      originalConsoleError.apply(console, args);\n    };\n  }\n  static isBrowserExtensionError(error) {\n    if (!error) return false;\n    const errorString = error.toString ? error.toString() : String(error);\n\n    // Common patterns for browser extension errors\n    const extensionPatterns = ['chrome-extension://', 'moz-extension://', 'safari-extension://', 'ms-browser-extension://', 'egjidjbpglichdcondbcbdnbeeppgdph',\n    // MetaMask extension ID\n    'nkbihfbeogaeaoehlefnkodbefgpgknn',\n    // MetaMask extension ID\n    'fhbohimaelbohpjbbldcngcnapndodjp',\n    // Binance extension ID\n    'Script error.', 'Non-Error promise rejection captured', 'inpage.js', 'contentscript.js'];\n    return extensionPatterns.some(pattern => errorString.includes(pattern));\n  }\n  static logError(type, error) {\n    // Only log errors in development\n    if (process.env.NODE_ENV === 'development') {\n      console.group(`ðŸš¨ ${type}`);\n      console.error(error);\n      console.groupEnd();\n    }\n\n    // In production, you might want to send to error tracking service\n    // Example: Sentry, LogRocket, etc.\n  }\n  static isExtensionEnvironment() {\n    var _chrome, _browser;\n    return !!((_chrome = window.chrome) !== null && _chrome !== void 0 && _chrome.runtime || (_browser = window.browser) !== null && _browser !== void 0 && _browser.runtime || document.querySelector('script[src*=\"extension://\"]'));\n  }\n}\n\n// Helper function to safely access potentially undefined objects\nexport function safeAccess(obj, path, defaultValue) {\n  try {\n    var _path$reduce;\n    return (_path$reduce = path.reduce((current, key) => current === null || current === void 0 ? void 0 : current[key], obj)) !== null && _path$reduce !== void 0 ? _path$reduce : defaultValue;\n  } catch (error) {\n    console.warn(`Safe access failed for path ${path.join('.')}: ${error}`);\n    return defaultValue;\n  }\n}\n\n// Debounced error reporter to prevent spam\nexport class ErrorReporter {\n  static report(error, context) {\n    const errorKey = error.toString();\n    const count = this.errorCounts.get(errorKey) || 0;\n    if (count >= this.MAX_SAME_ERROR) {\n      return; // Don't report the same error too many times\n    }\n    this.errorCounts.set(errorKey, count + 1);\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`[${context || 'App'}] Error:`, error);\n    }\n  }\n}\nErrorReporter.errorCounts = new Map();\nErrorReporter.MAX_SAME_ERROR = 5;","map":{"version":3,"names":["GlobalErrorHandler","init","window","addEventListener","event","console","warn","reason","isBrowserExtensionError","info","preventDefault","logError","error","filename","originalConsoleError","args","errorString","join","apply","toString","String","extensionPatterns","some","pattern","includes","type","process","env","NODE_ENV","group","groupEnd","isExtensionEnvironment","_chrome","_browser","chrome","runtime","browser","document","querySelector","safeAccess","obj","path","defaultValue","_path$reduce","reduce","current","key","ErrorReporter","report","context","errorKey","count","errorCounts","get","MAX_SAME_ERROR","set","Map"],"sources":["/Users/chungtran/Programming/guitar-chords/web/src/utils/errorHandler.ts"],"sourcesContent":["// Global error handler for browser extension conflicts and other errors\n\nexport class GlobalErrorHandler {\n  static init() {\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      console.warn('Unhandled promise rejection:', event.reason);\n      \n      // Prevent browser extension errors from crashing the app\n      if (this.isBrowserExtensionError(event.reason)) {\n        console.info('Browser extension error detected and ignored:', event.reason);\n        event.preventDefault();\n        return;\n      }\n      \n      // Log other errors for debugging\n      this.logError('Unhandled Promise Rejection', event.reason);\n    });\n\n    // Handle uncaught JavaScript errors\n    window.addEventListener('error', (event) => {\n      // Ignore browser extension errors\n      if (this.isBrowserExtensionError(event.error) || this.isBrowserExtensionError(event.filename)) {\n        console.info('Browser extension error detected and ignored:', event.error);\n        event.preventDefault();\n        return;\n      }\n      \n      this.logError('Uncaught Error', event.error);\n    });\n\n    // Override console.error to filter out extension errors\n    const originalConsoleError = console.error;\n    console.error = (...args: any[]) => {\n      const errorString = args.join(' ');\n      \n      // Don't log browser extension errors\n      if (this.isBrowserExtensionError(errorString)) {\n        return;\n      }\n      \n      originalConsoleError.apply(console, args);\n    };\n  }\n\n  private static isBrowserExtensionError(error: any): boolean {\n    if (!error) return false;\n    \n    const errorString = error.toString ? error.toString() : String(error);\n    \n    // Common patterns for browser extension errors\n    const extensionPatterns = [\n      'chrome-extension://',\n      'moz-extension://',\n      'safari-extension://',\n      'ms-browser-extension://',\n      'egjidjbpglichdcondbcbdnbeeppgdph', // MetaMask extension ID\n      'nkbihfbeogaeaoehlefnkodbefgpgknn', // MetaMask extension ID\n      'fhbohimaelbohpjbbldcngcnapndodjp', // Binance extension ID\n      'Script error.',\n      'Non-Error promise rejection captured',\n      'inpage.js',\n      'contentscript.js',\n    ];\n    \n    return extensionPatterns.some(pattern => \n      errorString.includes(pattern)\n    );\n  }\n\n  private static logError(type: string, error: any) {\n    // Only log errors in development\n    if (process.env.NODE_ENV === 'development') {\n      console.group(`ðŸš¨ ${type}`);\n      console.error(error);\n      console.groupEnd();\n    }\n    \n    // In production, you might want to send to error tracking service\n    // Example: Sentry, LogRocket, etc.\n  }\n\n  static isExtensionEnvironment(): boolean {\n    return !!(\n      (window as any).chrome?.runtime ||\n      (window as any).browser?.runtime ||\n      document.querySelector('script[src*=\"extension://\"]')\n    );\n  }\n}\n\n// Helper function to safely access potentially undefined objects\nexport function safeAccess<T>(obj: any, path: string[], defaultValue: T): T {\n  try {\n    return path.reduce((current, key) => current?.[key], obj) ?? defaultValue;\n  } catch (error) {\n    console.warn(`Safe access failed for path ${path.join('.')}: ${error}`);\n    return defaultValue;\n  }\n}\n\n// Debounced error reporter to prevent spam\nexport class ErrorReporter {\n  private static errorCounts = new Map<string, number>();\n  private static readonly MAX_SAME_ERROR = 5;\n\n  static report(error: Error | string, context?: string) {\n    const errorKey = error.toString();\n    const count = this.errorCounts.get(errorKey) || 0;\n    \n    if (count >= this.MAX_SAME_ERROR) {\n      return; // Don't report the same error too many times\n    }\n    \n    this.errorCounts.set(errorKey, count + 1);\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.error(`[${context || 'App'}] Error:`, error);\n    }\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}